#pragma kernel Flow

struct Agent {
    float2 position;
    float2 direction;
};

float Randomize(uint s)
{
    s ^= 2747636419u;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    return float(s) / 4294967295.0;
}

float Random(Agent a) {
    return Randomize(a.position.x * 3.56 + a.position.y + 11);
}

int width;
int height;
float speed;
float dt;
float sideAttractionWeight;
float centerAttractionWeight;
float turnAngleSin;
float turnAngleCos;
float sensorAngleSin;
float sensorAngleCos;
float sensorDistance;
bool randomBounce;

Agent MirrorBounce(Agent a)
{
    if (a.position.x < 0 ) {
        a.position.x = 0;
        a.direction.x = -a.direction.x;
    }
    if (a.position.x > width) {
        a.position.x = width;
        a.direction.x = -a.direction.x;
    }
    if (a.position.y < 0) {
        a.position.y = 0;
        a.direction.y = -a.direction.y;
    }
    if (a.position.y > height) {
        a.position.y = height;
        a.direction.y = -a.direction.y;
    }
    return a;
}

Agent RandomBounce(Agent a)
{
    if (a.position.x < 0 ) {
        a.position.x = 0;
        a.direction.x = Random(a);
        a.direction.y = Random(a) - 0.5;
    }
    if (a.position.x > width) {
        a.position.x = width;
        a.direction.x = -Random(a);
        a.direction.y = Random(a) - 0.5;
    }
    if (a.position.y < 0) {
        a.position.y = 0;
        a.direction.y = Random(a);
        a.direction.x = Random(a) - 0.5;
    }
    if (a.position.y > height) {
        a.position.y = height;
        a.direction.y = -Random(a);
        a.direction.x = Random(a) - 0.5;
    }
    a.direction = normalize(a.direction);
    return a;
}

Agent Bounce(Agent a)
{
    if (randomBounce) return RandomBounce(a);
    else return MirrorBounce(a);
}

float2 RightSensor(Agent a)
{
    return float2
        (
            a.position.x + (sensorAngleCos * a.direction.x + sensorAngleSin * a.direction.y) * sensorDistance,
            a.position.y + (-sensorAngleSin * a.direction.x + sensorAngleCos * a.direction.y) * sensorDistance
        );
}

float2 LeftSensor(Agent a)
{
    return float2
        (
            a.position.x + (sensorAngleCos * a.direction.x - sensorAngleSin * a.direction.y) * sensorDistance,
            a.position.y + (sensorAngleSin * a.direction.x + sensorAngleCos * a.direction.y) * sensorDistance
        );
}

float2 CenterSensor(Agent a)
{
    return float2
        (
            a.position.x + sensorDistance * a.direction.x,
            a.position.y + sensorDistance * a.direction.y
        );
}

float2 TurnRight(Agent a)
{
    return float2
        (
            (turnAngleCos * a.direction.x + turnAngleSin * a.direction.y),
            (-turnAngleSin * a.direction.x + turnAngleCos * a.direction.y)
        );
}

float2 TurnLeft(Agent a)
{
    return float2
        (
            (turnAngleCos * a.direction.x - turnAngleSin * a.direction.y),
            (turnAngleSin * a.direction.x + turnAngleCos * a.direction.y)
        );
}

RWTexture2D<float4> TrailMap;
RWTexture2D<float4> AgentMap;
RWStructuredBuffer<Agent> agents;

//updates every agent's position and direction'
[numthreads(64,1,1)]
void Flow (uint3 id : SV_DispatchThreadID)
{
    Agent agent = agents[id.x];
    float2 newPos = agent.position + agent.direction * speed * dt;

    agent.position = newPos;
    agent = Bounce(agent);

    float2 rightSensor = RightSensor(agent);
    float2 leftSensor = LeftSensor(agent);
    float2 centerSensor = CenterSensor(agent);

    float rightSignal = (TrailMap[rightSensor].x + TrailMap[rightSensor].y + TrailMap[rightSensor].z) / 3 * sideAttractionWeight;
    float leftSignal = (TrailMap[leftSensor].x + TrailMap[leftSensor].y + TrailMap[leftSensor].z) / 3 * sideAttractionWeight;
    float centerSignal = (TrailMap[centerSensor].x + TrailMap[centerSensor].y + TrailMap[centerSensor].z) / 3 * centerAttractionWeight;

    float strongestSignal = max(max(rightSignal, leftSignal), centerSignal);

    if (centerSignal == strongestSignal);
    else if (rightSignal == strongestSignal) agent.direction = TurnRight(agent);
    else if (leftSignal == strongestSignal) agent.direction = TurnLeft(agent);

    agents[id.x] = agent;
    TrailMap[newPos] = 1;
    AgentMap[newPos] = 1;
}