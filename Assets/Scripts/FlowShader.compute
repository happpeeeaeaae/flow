// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Render
#pragma kernel Flow

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
struct Agent {
    float2 position;
    float2 direction;
};

float Randomize(uint s)
{
    s ^= 2747636419u;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    return float(s) / 4294967295.0;
}

float Random(Agent a) {
    return Randomize(a.position.x * 3.56 + a.position.y + 11);
}

uint numAgents;
int width;
int height;
uint diffuseSize;
float speed;
float dt;
float decayRate;
float sideAttractionThreshhold;
float sideAttractionWeight;
float centerAttractionThreshhold;
float centerAttractionWeight;
float turnSpeed;
float sensorAngle;
float sensorDistance;
bool randomBounce;

Agent MirrorBounce(Agent a)
{
    if (a.position.x < 0 ) {
        a.position.x = 0;
        a.direction.x = -a.direction.x;
    }
    if (a.position.x > width) {
        a.position.x = width;
        a.direction.x = -a.direction.x;
    }
    if (a.position.y < 0) {
        a.position.y = 0;
        a.direction.y = -a.direction.y;
    }
    if (a.position.y > height) {
        a.position.y = height;
        a.direction.y = -a.direction.y;
    }
    return a;
}

Agent RandomBounce(Agent a)
{
    if (a.position.x < 0 ) {
        a.position.x = 0;
        a.direction.x = Random(a);
        a.direction.y = Random(a) - 0.5;
    }
    if (a.position.x > width) {
        a.position.x = width;
        a.direction.x = -Random(a);
        a.direction.y = Random(a) - 0.5;
    }
    if (a.position.y < 0) {
        a.position.y = 0;
        a.direction.y = Random(a);
        a.direction.x = Random(a) - 0.5;
    }
    if (a.position.y > height) {
        a.position.y = height;
        a.direction.y = -Random(a);
        a.direction.x = Random(a) - 0.5;
    }
    a.direction = normalize(a.direction);
    return a;
}

Agent Bounce(Agent a)
{
    if (randomBounce) return RandomBounce(a);
    else return MirrorBounce(a);
}

float2 RightSensor(Agent a)
{
    return float2
        (
            a.position.x + (cos(-sensorAngle) * a.direction.x - sin(-sensorAngle) * a.direction.y) * sensorDistance,
            a.position.y + (sin(-sensorAngle) * a.direction.x + cos(-sensorAngle) * a.direction.y) * sensorDistance
        );
}

float2 LeftSensor(Agent a)
{
    return float2
        (
            a.position.x + (cos(sensorAngle) * a.direction.x - sin(sensorAngle) * a.direction.y) * sensorDistance,
            a.position.y + (sin(sensorAngle) * a.direction.x + cos(sensorAngle) * a.direction.y) * sensorDistance
        );
}

float2 CenterSensor(Agent a)
{
    return float2
        (
            a.position.x + sensorDistance * a.direction.x,
            a.position.y + sensorDistance * a.direction.y
        );
}

float2 TurnRight(Agent a)
{
    return float2
        (
            (cos(-turnSpeed) * a.direction.x - sin(-turnSpeed) * a.direction.y),
            (sin(-turnSpeed) * a.direction.x + cos(-turnSpeed) * a.direction.y)
        );
}

float2 TurnLeft(Agent a)
{
    return float2
        (
            (cos(turnSpeed) * a.direction.x - sin(turnSpeed) * a.direction.y),
            (sin(turnSpeed) * a.direction.x + cos(turnSpeed) * a.direction.y)
        );
}

RWTexture2D<float4> TrailMap;
RWStructuredBuffer<Agent> agents;

[numthreads(8,8,1)]
void Render (uint3 id : SV_DispatchThreadID)
{
    int diff = (diffuseSize - 1) / 2;
    float4 blurValue = 0;
    for (int offsetX = -diff; offsetX <= diff; offsetX++)
        for (int offsetY = -diff; offsetY <= diff; offsetY++)
        {
            int x = id.x + offsetX;
            int y = id.y + offsetY;
            if (x >= 0 && x < width && y >= 0 && y < height)
                blurValue += TrailMap[int2(x, y)];
        }
    blurValue /= pow(((diff * 2) + 1), 2);
    TrailMap[id.xy] = blurValue;
    TrailMap[id.xy] -= decayRate * dt;
}

[numthreads(64,1,1)]
void Flow (uint3 id : SV_DispatchThreadID)
{
    Agent agent = agents[id.x];
    float2 newPos = agent.position + agent.direction * speed * dt;

    agent.position = newPos;
    agent = Bounce(agent);

    float2 rightSensor = RightSensor(agent);
    float2 leftSensor = LeftSensor(agent);
    float2 centerSensor = CenterSensor(agent);

    float rightSignal = (TrailMap[rightSensor].x + TrailMap[rightSensor].y + TrailMap[rightSensor].z) / 3 * sideAttractionWeight;
    float leftSignal = (TrailMap[leftSensor].x + TrailMap[leftSensor].y + TrailMap[leftSensor].z) / 3 * sideAttractionWeight;
    float centerSignal = (TrailMap[centerSensor].x + TrailMap[centerSensor].y + TrailMap[centerSensor].z) / 3 * centerAttractionWeight;

    float strongestSignal = max(max(rightSignal, leftSignal), centerSignal);

    if (centerSignal == strongestSignal);
    else if (rightSignal == strongestSignal) agent.direction = TurnRight(agent);
    else if (leftSignal == strongestSignal) agent.direction = TurnLeft(agent);

    agents[id.x] = agent;
    TrailMap[newPos] = 1;
}

    /*
    float2 tempPos = float2
        (
        Random(uint(agent.position.x * id.x * 17.44 * 11 + 11)) * width,
        Random(uint(agent.position.y * id.x * 17.56 * 17 + 10)) * height
        );
    */